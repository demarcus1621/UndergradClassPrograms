use work.dlx_types.all;
use work.bv_arithmetic.all;

entity alu is
	generic(prop_delay: Time:= 15 ns);
	port(operand_1, operand_2: in dlx_word; operation: in
		alu_operation_code;
		result: out dlx_word; error: out error_code);
end entity alu;

architecture behaviour of alu is
begin

	determine_opcode: process(operation, operand_1, operand_2) is -- Call proper function by opcode
	
	variable is_overflow: boolean;
	variable temp_result: bit_vector(31 downto 0);
	variable div_zero: boolean;
	
	begin
		case operation is
			when "0000" => -- unsigned add
				bv_addu(operand_1, operand_2, temp_result, is_overflow);
				result <= temp_result after prop_delay;
				if is_overflow then
					error <= integer_to_bv(1,4) after prop_delay;
				else
					error <= integer_to_bv(0,4) after prop_delay;
				end if;
			when "0001" => -- unsigned subtract
				bv_subu(operand_1, operand_2, temp_result, is_overflow);
				result <= temp_result;
				if is_overflow then
					error <= integer_to_bv(2, 4);
				else
					error <= integer_to_bv(0, 4);
				end if;
			when "0010" => -- two's complement add
				bv_add(operand_1, operand_2, temp_result, is_overflow);
				result <= temp_result;
				if is_overflow then
					if operand_1(operand_1'left) = '0' and operand_2(operand_2'left) = '0' then
						error <= integer_to_bv(1,4);
					else
						error <= integer_to_bv(2, 4);
					end if;
				else
					error <= integer_to_bv(0,4);
				end if;
			when "0011" => -- two's complement subtract
				bv_sub(operand_1, operand_2, temp_result, is_overflow);
				result <= temp_result;
				if is_overflow then
					if operand_1(operand_1'left) = '0' then
						error <= integer_to_bv(1,4);
					else
						error <= integer_to_bv(2,4);
					end if;
				else
					error <= integer_to_bv(0,4);
				end if;
			when "0100" => -- two's complement multiply
				bv_mult(operand_1, operand_2, temp_result, is_overflow);
				result <= temp_result;
				if is_overflow then
					if operand_1(operand_1'left) = operand_2(operand_2'left) then
						error <= integer_to_bv(1,4);
					else
						error <= integer_to_bv(2,4);
					end if;
				else
					error <= integer_to_bv(0,4);
				end if;
			when "0101" => -- two's complement divide
				bv_div(operand_1, operand_2, temp_result, div_zero, is_overflow);
				result <= temp_result; 
				if div_zero then
					error <= integer_to_bv(3,4);
				else
					error <= integer_to_bv(0,4);
				end if;
			when "0110" => -- logical AND (&&)
				if operand_1 /= integer_to_bv(0, operand_1'length) and operand_2 /= integer_to_bv(0, operand_2'length) then
					result <= integer_to_bv(1,operand_1'length);
					error <= integer_to_bv(0,4);
				else
					result <= integer_to_bv(1,operand_1'length);
					error <= integer_to_bv(0,4);
				end if;
			when "0111" => -- bitwise AND (&)
				result <= operand_1 and operand_2;
				error <= integer_to_bv(0,4);
			when "1000" =>  -- logical OR (||)
				if operand_1 /= integer_to_bv(0,operand_1'length) or operand_2 /= integer_to_bv(0,operand_2'length) then
					result <= integer_to_bv(1, operand_1'length);
					error <= integer_to_bv(0,4);
				else
					result <= integer_to_bv(0, operand_1'length);
					error <= integer_to_bv(0,4);
				end if;
			when "1001" => -- bitwise OR (|)
				result <= operand_1 or operand_2;
				error <= integer_to_bv(0,4);
			when "1010" => -- logical NOT (!)
				if operand_1 /= integer_to_bv(0, operand_1'length) then
					result <= integer_to_bv(1, operand_1'length);
					error <= integer_to_bv(0,4);
				else
					result <= integer_to_bv(1, operand_1'length);
					error <= integer_to_bv(0,4);
				end if;
			when "1011" => -- bitwise NOT (~)
				result <= not operand_1;
				error <= integer_to_bv(0,4);
			when others =>  
				result <= integer_to_bv(0, 32);
				error <= integer_to_bv(0, 4);
		end case;
	end process determine_opcode;
end architecture behaviour;